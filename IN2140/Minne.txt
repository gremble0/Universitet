Oppgave 1: Layout

1)	Siden utførelsen av et program er det vi kaller en prosess vil jeg si at et kodesegment 
	inneholder både deler av programmet og prosessen. Til tross for dette vil jeg si at det 
	inneholder en større andel av program enn prosess ettersom det er flere andre ting som går 
	inn i en prosess.

2)	Ved å ha to separate dataområder i minne kan vi lagre to forskjellige typer data.
	I stacken: 	Midlertidige lokale variabler vi glemmer etter vi går ut av kodeblokker.
				Dette er her vi lagrer dynamiske verdier i tillegg til at vi holder styr på 
				rekkefølgen koden skal eksekveres i og hvor vi skal hoppe til ved funksjonskall osv.
	I heapen:	Globale variabler vi skal beholde gjennom hele programmet. Heapen er tregere 
				enn stacken og bruker en hierarkisk datastruktur fremfor stackens lineære.
	Dersom minneområde til stacken overtrer inn i heapen vil vi få en stackoverflow error, og en
	heapoverflow når det motsatte skjer. Dette vil ideelt sett kræsje programmet men kan også
	utnyttes av en angreper til andre hensikter.

3)	En prosess bruker både stacken og heapen. For å kunne bruke variabler utenfor en funksjon
	må man allokere minne i heapen for den. Det er dette vi gjør når vi bruker malloc(). Ellers
	blir lokale variabler lagret i stacken. Dette er raskere og billigere, men vanskeligere å
	håndtere.

	Man kunne klart seg med å bare bruke både heapen og allokere alt med malloc(), eller ved å
	ha hele programmet i main funksjonen med lokale variabler og dermed bare bruke stacken.
	Hverken av disse løsningene er anbefalt. // litt usikker

Oppgave 2: Partisjonering

	// Jeg løste med segmentering som ikke er lov - feil svar.

1)	Siden har 1MiB minne og prosesser som til sammen krever 1MiB minne har vi nok minne
	til å kjøre alle disse prosessene samtidig. Men siden vi bruker en statisk partisjonering
	som ikke kan gi de to prosessene som krever 64KiB noe mindre enn 128MiB vil vi på det punktet
	vi kommer til prosess E måtte fragmentere den inn i samme partisjon som andre prosesser
	slik de gjør på slutten av kjøretidsplanen. Eventuelt kunne vi flyttet to av de 64KiB prosessene
	i samme partisjon. Uansett måtte vi fragmentert prosess E til minst 2 partisjoner.

2)	Med first fit minneallokering hadde vi ikke fått noen fragmentering siden etter prosess A terminerer
	fylles den 128KiB blokken av minne opp igjen av prosess C og D. Så legger den seg tilbake på toppen
	av minne når den starter igjen. Når prosess E skal starte er det da en full 512KiB blokk minne 
	ledig på toppen av minne og en 64KiB blokk på bunnen for at prosess C kan starte opp igjen.

	Med next fit vil vi sitte igjen med 384KiB på toppen av minne som den største blokken minne. Dette er 
	fordi at når prosess A og C terminerer forblir disse hullene i minne liggende før prosess A starter igjen
	og okkuperer deler av det prosess E trenger for å ikke skape fragmentering. Altså må vi fragmentere 
	prosess E inn i en 384KiB partisjon og en 128KiB partisjon. Prosess C kan starte i samme minneområde uten
	fragmentering.




